//===== EinherjarRO Scripts ==================================
//= Auto Event
//===== By: ==================================================
//= Stolao
//===== Current Version: =====================================
//= 2.63
//===== Compatible With: =====================================
//= rAthena SVN
//===== Description: =========================================
//= Auto Event
//===== Comments: ============================================
//= [Stolao]
// Instance.yml
//  - Id: 44
//    Name: Emp Breaker
//    TimeLimit: 900
//    Enter:
//      Map: sword_1-1
//      X: 215
//      Y: 206
//
//	src/map/chat.h
//	#define MAX_CHAT_USERS 20
//		Increase as needed for your server size
//
//===== To Do: ===============================================
//= No Range MF
//= No Arealoot
//= No Cost MF
//= Make Rewards Editable in game
//= Add A Vote4Event(ingame) Feature
//= Add Events; Invasion, X-O Event, MVP Arena,
//=	Dead Branch, Safetywall
//= Add Other Requested Events
//= Fix Manually Removing Events Overflow Error (not game breaking)
//= Guess monster based of what it says event
//= Emp Defender
//= Find Stolao
//= DDR
//= Tower Defence
//===== Additional Comments: =================================
//= 2.4F Fixed incorrect event index for Mushroom and Bapho events
//= 2.50 Added a Gm diplay count for mob counting event if Testmode is enabled
//= 2.51 Removed map warp from counting event
//= 2.52 Counting event now properly removes mobs at events end
//= 2.53 Removed SQL dependency from Fabre event
//= 2.54 Added Warp out for disgusie event
//= 2.55 Disabled Countdown timer in disguse event
//= 2.56 Fixed incorrect Rules check
//= 2.57 Added a Gm diplay mob name for disguise event for gm 99
//= 2.58 Fixed incorrect mapindex for disguise event
//= 2.59 Devil Square now rewards all players once last chest is killed
//= 2.5A Fabre event now propery kills monsters at end
//= 2.5B Replace all Announce with announce, for consistancy
//= 2.5C Added testmode command
//= 2.5D Added Player Count to Event Announcement
//= 2.5E Fixed a few events not giving prizes
//= 2.5F Fixed a bunch of stuff on Stream, Vod: https://youtu.be/EM2t_HqHlkc
//= 2.60 Fixed a missing song
//= 2.61 Added more songs
//= 2.62 Removed Custom Mapflags for release
//= 2.63 Removed Discord intigration for release
//===== Contact Ifo: =========================================
//= [Stolao] 
//= Email: Taingram11@gmail.com
//============================================================

//==================================
//-- Reward Function
//==================================

function	script	Func_Prizes	{
	announce "Congrats "+strcharinfo(0,getarg(0))+", a winner in the "+getarg(1)+" Event, check your mail for your reward.",bc_all|bc_blue;
	if(!getattachedrid())
		attachrid(getcharid(3,strcharinfo(0,getarg(0))),1);
	
	WonEvents++;
	MWonEvents++;
	if($@Mail){
		mail getarg(0), "no-reply", getarg(1), "Congratulations!% You have won in the "+getarg(1)+" % % % [ Your reward is attached. ]", $@RewardZeny, $@RewardID, $@RewardQNT;
		query_sql("UPDATE `mail` SET message = REPLACE(message,'%',CHAR(13)) WHERE send_name = 'no-reply'");
	} else {
		getitem $@RewardID,$@RewardQNT;
		zeny += $@RewardZeny;
	}
	return;
}

//==================================
//-- Core Script
//==================================

prontera,164,171,4	script	Event Information	835,{
	function Func_Countdown;
	function Func_Add_Time;
	freeloop(1);

//==================================
		//-- Special Checks
//==================================

	if($@CurrentEvent == -14){
		if(getgmlevel() >= .GMAccess && .TestMode)
			dispbottom .MobCount[.Target]+"";
		input .@answer;
		if(.@answer == .MobCount[.Target])
			doevent strnpcinfo(3)+"::OnRightCount";
		else	doevent strnpcinfo(3)+"::OnSpam";
		end;
	} else if($@CurrentEvent == -18){
		if(getgmlevel() >= .GMAccess && .SongID)
			dispbottom .SongName$[.SongID];
		input .@answer$;
		if(.@answer$ == .SongName$[.SongID])
			doevent strnpcinfo(3)+"::OnRightSong";
		else	doevent strnpcinfo(3)+"::OnSpam";
		end;
	} 

//==================================
OnMenu:		//-- Click Menus
//==================================

	mes "[ Event Information ]";
	if($@CurrentEvent > 0)
		mes "Current Event: ",.ColorName$[$@CurrentEvent]," ";
	.@Time = gettime(4) * 24 + gettime(3);
	for(.@i = .@Time + ((gettime(2)>.StartTime?1:0)); .@i < .@Time + 168; .@i++){
		if($EVENT_CONTROL[.@i%168]){
			mes "Next Event:",.ColorName$[ $EVENT_CONTROL[ (.@i % 168) ] ] +" ~ "+ .Days$[ .@i % 168 / 24 ] +" - "+ Func_Add_Time( (.@i % 168) % 24);
			.@e += 1;
			break;
		}
	}
	if(!.@e) mes "Auto Events Disabled.";
	switch(select((($@CurrentEvent > 0)?" ~ Join event...:":":")+
			((.@e)?" ~ Check schedule...:":":")+
			((getgmlevel() < .GMAccess)?":":" ~ Manage events...:")+
			(($@EventRanking & 1)?" ~ Monthly Ranking:":":")+
			(($@EventRanking & 2)?" ~ Lifetime Ranking:":":")+
			": ~ ^777777Cancel^000000")) {
		case 2:
			for(.@i = 0; .@i < 168; .@i++){
				if( !( ( .@i ) % 24 )){
					next;
					mes "[ "+ .Days$[.@i / 24] +" Event Schedule ]";
				}
				if($EVENT_CONTROL[.@i])
					mes .ColorName$[$EVENT_CONTROL[.@i]] +" ~ "+ Func_Add_Time(.@i % 24);
			}	
			close;
		case 4:
			query_sql("SELECT char_id, CAST(`value` AS SIGNED) FROM `char_reg_num` WHERE `key` = 'MWonEvents' ORDER BY CAST(`value` AS SIGNED) DESC LIMIT 10",.@cid,.@value);
		case 5:
			if(!.@cid)
				query_sql("SELECT char_id, CAST(`value` AS SIGNED) FROM `char_reg_num` WHERE `key` = 'WonEvents' ORDER BY CAST(`value` AS SIGNED) DESC LIMIT 10",.@cid,.@value);
			for(.@x = 0; .@x < getarraysize(.@cid); .@x++) {
				query_sql("SELECT `name` FROM `char` WHERE char_id = "+.@cid[.@x]+";",.@j$);
				.@name$[.@x] = .@j$;
			}
			next;
			mes "~ ^990000"+((.@m)?"Monthly ":"") +"Event Ladder^000000 ~";
			if (!getarraysize(.@cid))
				mes "The rankings are empty.";
			else {
				for(.@i = 0; .@i < getarraysize(.@cid); .@i++)
					mes "#"+(.@i+1)+" ^0000FF"+.@name$[.@i]+"^000000 "+.@value[.@i];
			}
			close;
		case 3:
		while(1){
			switch(select(" ~ Add an event...: ~ Delete an event...: ~ End current event: ~ Randomize event list: ~ Add event type: ~ Remove event type: ~ Reset queue:~ ^777777Go back^000000")) {
				case 3:	next;
					goto OnEndEvent;
				case 4:	next;
					goto OnRandomize;
				case 5:	next;
					goto OnAddType;
				case 6:	next;
					goto OnRemoveType;
				case 7:	next;
					goto OnClear;
				case 8:	next;
					goto OnMenu;
				case 1:
					next;
					mes "[ Add Event ]";
					mes "Pick a Day.";
					.@Day = select(" ~ "+implode(.Days$,": ~ ")) - 1;
					next;
					mes "[ Add Event ]";
					mes "Pick a Time for ^0055FF"+.Days$[.@D / 24]+".";
					.@menu$ = "";
					.@e = 0;
					for(.@i = .@Day * 24; .@i < .@Day * 24 + 24; .@i++){
						if(!$EVENT_CONTROL[.@i]){
							.@menu$ = .@menu$ +" ~ "+ Func_Add_Time( .@i % 24 ) +":";
							.@e += 1;
						} else	.@menu$ = .@menu$ + ":";
					}
					if(!.@e){
						mes "No Events Times Remaining for "+ .Days$[ .@Day ] +".";
						close;
					}
					.@D = select(.@menu$) + .@Day * 24 - 1;
					next;
					mes "[ Add Event ]";
					mes "Select a event for ^0055FF"+ .Days$[.@D / 24] +" ~ "+ Func_Add_Time(.@D % 24) +"^000000.";
					next;
					.@Event = select(implode(.ColorName$,": ~ ")) - 1;
					mes "Are you sure you want to add "+ .ColorName$[.@Event] +",";
					mes "for ^0055FF"+ .Days$[.@D / 24] +" ~ "+ Func_Add_Time(.@D % 24) +"^000000?";
					next;
					.@A = (select(" ~ ^0000CCAdd event...^000000: ~ ^777777Cancel^000000"));
					mes "[ Add Event ]";
					if(.@A == 2)
						mes "Cancelled.";
					else {
						$EVENT_CONTROL[.@D] = .@Event;
						mes "Event Added.";
					}
					break;
				case 2:
					next;
					mes "[ Remove Event ]";
					mes "Which Event?";
					.@menu$ = "";
					for(.@i = .@e = 0; .@i < 168; .@i++){
						if($EVENT_CONTROL[.@i]){
							.@menu$ = .@menu$ + .Days$[ .@i / 24 ] +" - "+ Func_Add_Time( .@i % 24 ) +" ~ "+ .ColorName$[ $EVENT_CONTROL[ .@i ] ]+":";
							.@e += 1;
						} else	.@menu$ = .@menu$ + ":";
					}
					if(!.@e){
						mes "No Events Setup.";
						close;
					}
					.@D = select(.@menu$) - 1;
					next;
					mes "[ Remove Event ]";
					mes "Are you sure you want to add the "+ .ColorName$[.@D] +",";
					mes "for ^0055FF"+ .Days$[.@D % 168 / 24] +" ~ "+ Func_Add_Time(.@D % 168 / 24) +"^000000?";
					.@A = (select(" ~ ^FF0000Remove event...^000000: ~ ^777777Cancel^000000"));
					if(.@A == 2){
						mes "Cancelled.";
					} else {
						$EVENT_CONTROL[.@D] = 0;
						mes "Event Removed.";
					}
					break;
			}
		}
		case 6: close;
		case 1:
			next;
			break;
	}

//==================================
OnJoinEvent:	//-- Join Event
//==================================

	if($@CurrentEvent < 1){
		mes "[ Event Management ]","Sorry no event is running.";
		close;
	} else {
		.@c = checkhomcall();
		mes "[ "+ .EventName$[$@CurrentEvent] +" ]","Want to join the "+ .ColorName$[$@CurrentEvent] +"?";
		if($@CurrentEvent == 2)
			mes "[ "+ .EventName$[$@CurrentEvent] +" ]","Must be a Novice Level 10/10 or lower.";
		if($@CurrentEvent == 5 || $@CurrentEvent == 6 || $@CurrentEvent == 7)
			mes "[ "+ .EventName$[$@CurrentEvent] +" ]","Will have any Carts or Pets Removed.";
		if(select("Yes:No") == 2)
			mes "[ "+ .EventName$[$@CurrentEvent] +" ]","Ok come back later.",bc_self|bc_blue;
		else if((Baselevel > 10 || JobLevel > 10 || Class != Job_Novice ) && $@CurrentEvent == 2)
			mes "[ "+ .EventName$[$@CurrentEvent] +" ]","Sorry you must be a Novice Level 10/10 or lower.";
		else if($@CurrentEvent < 1)
			mes "[ Event Management ]","Sorry event closed before you hit yes.";
		else if(.@c != 1 && .@c != -1 && ($@CurrentEvent == 2 || $@CurrentEvent == 6 || $@CurrentEvent == 9 || $@CurrentEvent == 16))
			mes "[ "+ .EventName$[$@CurrentEvent] +" ]","No homunculus allowed, put it away before joining.";
		else {
			if($@CurrentEvent >= 5 && $@CurrentEvent <= 9){
				if(checkmadogear()){
					if(checkweight(33017,1)){
						getitem 33017,1;
						setmadogear 0;
					} else {
						next;
						mes "[ Event Management ]","Seems you're in a Mado Gear and cant seem to carry a voucher, either remove the Mado Gear or come back when you can hold the voucher.";
						close;
					}
				}
				if(checkdragon()){
					if(checkweight(33018,1)){
						getitem 33018,1;
						setdragon 0;
					} else {
						next;
						mes "[ Event Management ]","Seems you're on a Dragon and can't seem to carry a voucher, either remove you're Dragon or come back when you can hold the voucher.";
						close;
					}
				}			
				if(checkwug()){
					if(checkweight(33019,1)){
						getitem 33019,1;
						setoption Option_Wugrider,0;
					} else {
						next;
						mes "[ Event Management ]","Seems you're on a Wug and can't seem to carry a voucher, either remove you're Wug or come back when you can hold the voucher.";
						close;
					}
				}
				if(ismounting()){
					if(checkweight(33020,1)){
						getitem 33020,1;
						setmounting;
					} else {
						next;
						mes "[ Event Management ]","Seems you're mounted and can't seem to carry a voucher, either remove you're mount or come back when you can hold the voucher.";
						close;
					}
				}
				if(checkriding()){
					if(checkweight(33021,1)){
						getitem 33021,1;
						setriding 0;
					} else {
						next;
						mes "[ Event Management ]","Seems you're mounted and can't seem to carry a voucher, either remove you're mount or come back when you can hold the voucher.";
						close;
					}
				}
				if(checkfalcon()){
					if(checkweight(33022,1)){
						getitem 33022,1;
						setfalcon 0;
					} else {
						next;
						mes "[ Event Management ]","Seems you have  a falcon and can't seem to carry a voucher, either remove you're falcon or come back when you can hold the voucher.";
						close;
					}
				}
				if(geteleminfo(1) > 0)
					unitkill geteleminfo(1);
				callfunc("dispell");
			} else if($@CurrentEvent == 2)
				callfunc("dispell");
			.register_aid[ .register_count ] = getcharid(3);
			.register_count++;
			if($@CurrentEvent == 13){
				delitem .candy_id, countitem( .candy_id );
				delitem .apple_id, countitem( .apple_id );
			}
			if($@CurrentEvent == 13 && checkcart()){
				if(checkweight(33023,1)){
					getitem 33023,1;
					setcart 0;
				} else {
					next;
					mes "[ Event Management ]","Seems you have cart and can't seem to carry a voucher, either remove you're cart or come back when you can hold the voucher.";
					close;
				}	
			}
			fabre = 0;
			warp .EnterMap$[$@CurrentEvent],.EnterX[$@CurrentEvent],.EnterY[$@CurrentEvent];
		}
	}
	close;

//==================================
OnRandomize:	//-- Randomize Event
//==================================

	mes "[ Randomize Event ]";
	mes "Chance of no event?";
	input(.@j,0,100);
	freeloop(1);
	for(.@i = 0; .@i < 168; .@i++){
		if(rand(100) < .@j){
			$EVENT_CONTROL[.@i] = 0;
			continue;
		}
		$EVENT_CONTROL[.@i] = rand(getarraysize(.EventName$));
		if($EVENT_CONTROL[.@i] == .@lastevent)
			$EVENT_CONTROL[.@i] = rand(getarraysize(.EventName$));
		.@lastevent = $EVENT_CONTROL[.@i];
	}
	freeloop(0);
	next;
	mes "[ Randomize Event ]";
	mes "Events set.";
	close;

//==================================
OnClear:	//-- Clear Event
//==================================

	mes "[ Clear Event Queue ]";
	mes "Wipe the event Queue?";
	if(select("No:Yes")== 1)
		close;
	freeloop(1);
	for(.@i = 0; .@i < 168; .@i++)
		$EVENT_CONTROL[.@i] = 0;
	freeloop(0);
	next;
	mes "[ Clear Event Queue ]";
	mes "Events Cleared.";
	close;

//==================================
OnRemoveType:	//-- Remove Event Type
//==================================

	mes "[ Remove Event Type ]";
	Mes "Which Event Would you Like to remove?";
	.@select = select(implode(.ColorName$,": ~ ")) - 1;
	next;
	mes "[ Remove Event Type ]";
	mes "Are you sure you want to remove all "+.ColorName$[.@select]+"?";
	if(select("No:Yes")== 1)
		close;
	freeloop(1);
	for(.@i = 0; .@i < 168; .@i++){
		if($EVENT_CONTROL[.@i] == .@select){
			$EVENT_CONTROL[.@i] = 0;
			continue;
		}
	}
	freeloop(0);
	next;
	mes "[ Remove Event Type ]";
	mes "All "+.ColorName$[.@select]+" Events Removed.";
	close;

//==================================
OnAddType:	//-- Add Event Type
//==================================

	mes "[ Add Event Type ]";
	Mes "Which Event Would you Like to add?";
	.@select = select(implode(.ColorName$,": ~ ")) - 1;
	next;
	mes "[ Add Event Type ]";
	mes "What chance would you like "+.ColorName$[.@select]+" to appear?";
	input(.@j,0,100);
	next;
	mes "[ Add Event Type ]";
	mes "Would you like "+.ColorName$[.@select]+" to overwrite other events?";
	.@Over = select("No:Yes") - 1;
	next;
	mes "[ Add Event Type ]";
	mes "Are you sure you want to add "+.ColorName$[.@select]+" at a "+.@j+"% chance"+((.@Over)?" overwriting other events":"")+"?";
	if(select("No:Yes")== 1)
		close;
	freeloop(1);
	for(.@i = 0; .@i < 168; .@i++){
		if(rand(100) > .@j || (!.@Over && $EVENT_CONTROL[.@i]))
			continue;
		else $EVENT_CONTROL[.@i] = .@select;
	}
	freeloop(0);
	next;
	mes "[ Add Event Type ]";
	mes .ColorName$[.@select]+" Added.";
	close;

//==================================
OnEndEvent:	//-- End Event
//==================================

	if($@CurrentEvent == 0){
		mes "[ Event Management ]","Sorry no event is running.";
		close;
	}
	if($@CurrentEvent < 0)
		$@CurrentEvent *= -1;
	switch($@CurrentEvent){
		default:
			mapwarp .EnterMap$[$@CurrentEvent],"prontera",155,172;
		case 1:	case 8:	case 7:
			break;
		case 2:	case 6:	case 9:
		case 16:	case 17:
			killmonsterall .EnterMap$[$@CurrentEvent];
			mapwarp .EnterMap$[$@CurrentEvent],"prontera",155,172;
			break;
		case 11:
			killmonster .Map$[11],strnpcinfo(3)+"::OnShroomKilled";
			mapwarp .EnterMap$[$@CurrentEvent],"prontera",155,172;
			break;
		case 12:
			killmonster .Map$[11],strnpcinfo(3)+"::OnBaphoKilled";
			mapwarp .EnterMap$[$@CurrentEvent],"prontera",155,172;
			break;
		case 14:
			killmonster .Map$[14],strnpcinfo(3)+"::OnKilled";
			mapwarp .EnterMap$[$@CurrentEvent],"prontera",155,172;
			break;
	}
	announce "Sorry a GM has stopped the "+ .EventName$[$@CurrentEvent] +".",bc_all|bc_blue;
	$@CurrentEvent = 0;
	delwaitingroom;
	end;

//==================================
OnRunEvent:	//-- GM Run
//==================================

	if($@CurrentEvent)
		mes "[ Event Management ]","Sorry an event is already running";
	else if(agitcheck() || agitcheck2())
		mes "[ Event Management ]","Sorry cannot run event during woe";
	else {
		mes "[ Event Management ]","Pick an Event.";
		.@i = select(implode(.ColorName$,": ~ ") +":Bug Test") - 1;
	}
	deletearray .register_aid;
	.register_count = 0;
	switch(.@i){
		case 0:							break;
		case 1: donpcevent strnpcinfo(3)+"::OnEmpStart";	break;
		case 2: donpcevent strnpcinfo(3)+"::OnZombieStart";	break;
		case 3: donpcevent strnpcinfo(3)+"::OnDiceStart";	break;
		case 4: donpcevent strnpcinfo(3)+"::OnPvPStart";	break;
		case 5: donpcevent strnpcinfo(3)+"::OnMazeStart";	break;
		case 6: donpcevent strnpcinfo(3)+"::OnPoringStart";	break;
		case 7: donpcevent "Cluckers::OnEventStart";		break;
		case 8: donpcevent strnpcinfo(3)+"::OnLuckyStart";	break;
		case 9: donpcevent strnpcinfo(3)+"::OnBombStart";	break;
		case 10: donpcevent strnpcinfo(3)+"::OnHuntStart";	break;
		case 11: donpcevent strnpcinfo(3)+"::OnShroomStart";	break;
		case 12: donpcevent strnpcinfo(3)+"::OnBaphoStart";	break;
		case 13: donpcevent strnpcinfo(3)+"::OnCandyStart";	break;
		case 14: donpcevent strnpcinfo(3)+"::OnCountStart";	break;
		case 15: donpcevent strnpcinfo(3)+"::OnDisguiseStart";	break;
		case 16: donpcevent strnpcinfo(3)+"::OnFabreStart";	break;
		case 17: donpcevent strnpcinfo(3)+"::OnDevilStart";	break;
		case 18: donpcevent strnpcinfo(3)+"::OnSongStart";	break;
		default: Func_Prizes(getcharid(0),"Bug Test");		break;
	}
	close;

//==================================
OnTestMode:	// Enable / Disable Testmode
//==================================

	if(.@atcmd_numparameters){
		if(.@atcmd_parameters$ == "1" || .@atcmd_parameters$ == "On" || .@atcmd_parameters$ == "Enable" || .@atcmd_parameters$ == "on" || .@atcmd_parameters$ == "enable"){
			if(.TestMode)
				announce "[Auto Events]: Debug Mode Already Enabled.",bc_self|bc_blue;
			else	announce "[Auto Events]: Debug Mode Enabled.",bc_self|bc_blue;
			.TestMode = 1;
		} else if(.@atcmd_parameters$ == "0" || .@atcmd_parameters$ == "Off" || .@atcmd_parameters$ == "Disable" || .@atcmd_parameters$ == "off" || .@atcmd_parameters$ == "disable"){
			if(.TestMode)
				announce "[Auto Events]: Debug Mode Disabled.",bc_self|bc_blue;
			else	announce "[Auto Events]: Debug Mode Already Disabled.",bc_self|bc_blue;
			.TestMode = 0;
		} else	announce "[Auto Events]: Test Mode may be enabled with, 1 | On | Enable or disabled with 0 | Off | Disable.",bc_self|bc_blue;
	} else {
		if(.TestMode){
			announce "[Auto Events]: Debug Mode Disabled.",bc_self|bc_blue;
			.TestMode = 0;
		} else {
			announce "[Auto Events]: Debug Mode Enabled.",bc_self|bc_blue;
			.TestMode = 1;
		}
	}
	end;

//==================================
		//-- Functions
//==================================

function Func_Add_Time {
	return ( ( (getarg(0) < 10)?"0":"" ) + getarg(0) + "." + ( (.StartTime < 10)?"0":"" ) + .StartTime );
}

function Func_Countdown {
	for(.@i = 5; .@i > 0; .@i--){
		announce .EventName$[$@CurrentEvent]+" will begin in "+ callfunc("F_InsertPlural",.@i,"minute") +"!",bc_all|bc_blue;
		if(.MinPlayers[$@CurrentEvent] > 1){
			if($@CurrentEvent == 1 || $@CurrentEvent == 8){
				getwaitingroomusers strnpcinfo(3);
				announce "Please type @joinevent to join, "+.@waitingroom_usercount+"/"+.MinPlayers[$@CurrentEvent]+" players have joined.",bc_all|bc_blue;
			} else	announce "Please type @joinevent to join, "+getmapusers(.EnterMap$[$@CurrentEvent])+"/"+.MinPlayers[$@CurrentEvent]+" players have joined.",bc_all|bc_blue;
		} else	announce "Please type @joinevent to join.",bc_all|bc_blue;
		if(.TestMode)
			sleep 6000;
		else	sleep 60000;
	}
	announce .EventName$[$@CurrentEvent] +" Has Begun!",bc_all|bc_blue;
	return;
}

//==================================
OnMinute00:	//- Start Events
//==================================

	if(gettime(DT_DAYOFMONTH) == 1 && gettime(DT_HOUR) == 0)
		query_sql("DELETE FROM `char_reg_num` WHERE `key` = 'MWonEvents'");
	if(agitcheck() || agitcheck2() || $@CurrentEvent) end;
	sleep .StartTime * 60000 + 1000;
	.@Time = gettime(4) * 24 + gettime(3);
	deletearray .register_aid;
	.register_count = 0;
	switch($EVENT_CONTROL[.@Time]){
		default:						break;
		case 1: donpcevent strnpcinfo(3)+"::OnEmpStart";	break;
		case 2: donpcevent strnpcinfo(3)+"::OnZombieStart";	break;
		case 3: donpcevent strnpcinfo(3)+"::OnDiceStart";	break;
		case 4: donpcevent strnpcinfo(3)+"::OnPvPStart";	break;
		case 5: donpcevent strnpcinfo(3)+"::OnMazeStart";	break;
		case 6: donpcevent strnpcinfo(3)+"::OnPoringStart";	break;
		case 7: donpcevent "Cluckers::OnEventStart";		break;
		case 8: donpcevent strnpcinfo(3)+"::OnLuckyStart";	break;
		case 9: donpcevent strnpcinfo(3)+"::OnBombStart";	break;
		case 10: donpcevent strnpcinfo(3)+"::OnHuntStart";	break;
		case 11: donpcevent strnpcinfo(3)+"::OnShroomStart";	break;
		case 12: donpcevent strnpcinfo(3)+"::OnBaphoStart";	break;
		case 13: donpcevent strnpcinfo(3)+"::OnCandyStart";	break;
		case 14: donpcevent strnpcinfo(3)+"::OnCountStart";	break;
		case 15: donpcevent strnpcinfo(3)+"::OnDisguiseStart";	break;
		case 16: donpcevent strnpcinfo(3)+"::OnFabreStart";	break;
		case 17: donpcevent strnpcinfo(3)+"::OnDevilStart";	break;
		case 18: donpcevent strnpcinfo(3)+"::OnSongStart";	break;
	}
	end;

//==================================
OnEmpStart:	//-- Emperium Event
//==================================

	$@CurrentEvent = 1;
	waitingroom "Emperium Event",99;
	Func_Countdown;
	$@CurrentEvent = -1;
	$@BestTime = 2000000000;
	$@BestCid = 0;
	getwaitingroomusers strnpcinfo(3);
	if(.@waitingroom_usercount >= .MinPlayers[1]){
		freeloop(1);
		for(.@i = 0; .@i < .@waitingroom_usercount; .@i++){
			attachrid(.@waitingroom_users[.@i]);
			callfunc("dispell");
			if(instance_id(IM_CHAR))
				instance_destroy(IM_CHAR);
			instance_create("Emp Breaker",IM_CHAR);
			instance_enter("Emp Breaker",215,206,getcharid(0),instance_id(IM_CHAR));
		}
		freeloop(0);
		delwaitingroom;
		if(.TestMode)
			sleep 60000;
		else
			sleep 10000;
	} else {
		delwaitingroom;
		announce .EventName$[1]+" Stopped! Not Enough Players Joined the "+.EventName$[1]+"!",bc_blue|bc_area|bc_npc;
	}
	if($@BestCid)
		Func_Prizes($@BestCid,.EventName$[1]);
	$@CurrentEvent = 0;
	end;

//==================================
OnZombieStart:	//-- Zombie Event
//==================================

	mapwarp .EnterMap$[2],"prontera",155,172;
	$@CurrentEvent = 2;
	Func_Countdown;
	$@CurrentEvent = -2;
	if(getmapusers(.EnterMap$[2]) < .MinPlayers[2]){
		mapannounce .EnterMap$[2],.EventName$[2]+" Stopped! Not Enough Players Joined the "+.EventName$[2]+"!",bc_blue;
		mapwarp .EnterMap$[2],"prontera",155,172;
	} else {
		mapannounce .EnterMap$[2],"Rules are simple, don't die before the end of round 10!",bc_blue;
		sleep 25000;
		for(.@wave = 1; .@wave < 11; .@wave++){
			if(.@wave < 10)
				mapannounce .EnterMap$[2],"Wave "+.@wave+"!",bc_blue;
			else	mapannounce .EnterMap$[2],"FINAL WAVE!",bc_blue;
			sleep 1000;
			for(.@i = 5; .@i > 0; .@i--){
				mapannounce .EnterMap$[2],""+.@i+"...",bc_blue;
				sleep 1000;
			}
			mapannounce .EnterMap$[2],"Begin Wave!",bc_blue;
			for(.@i = 0; (.@i < getarraysize(.Zombies)); .@i += 2)
				monster .EnterMap$[2],0,0,"--ja--",.Zombies[.@i], .@wave * .Zombies[.@i+1],strnpcinfo(3)+"::OnKillZombie";
			if(!getmapusers(.EnterMap$[2])){
				.@wave += 255;
			} else {
				mapannounce .EnterMap$[2],"There "+((getmapusers(.EnterMap$[2])>1)?"are":"is")+" "+callfunc("F_InsertPlural",getmapusers(.EnterMap$[2]),"player")+" left",bc_blue;
				sleep 55000;
			}
		}
		killmonsterall .EnterMap$[2];
		if(getmapusers(.EnterMap$[2])){
			addrid(5,0,.EnterMap$[2]);
			if(HP > 0 && strcharinfo(3) == .EnterMap$[2])
				Func_Prizes(getcharid(0),.EventName$[2]);
		}
	}
	$@CurrentEvent = 0;
	mapwarp .EnterMap$[2],"prontera",155,172;
	end;

OnKillZombie:
	dispbottom "Don't do that",0xCC0000;
	sc_start SC_DECREASEAGI,30000,10;
	percentheal -20,-100;
	heal -5,0;
	end;

//==================================
OnDiceStart:	//-- Dice Event 
//==================================

	mapwarp .EnterMap$[3],"prontera",155,172;
	$@CurrentEvent = 3;
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[5], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -3;
	if(getmapusers(.EnterMap$[3]) < .MinPlayers[3]){
		mapannounce .EnterMap$[3],"Event Stopped! Not Enough Players Joined the "+.EventName$[3]+"!",bc_blue;
		mapwarp .EnterMap$[3],"prontera",155,172;
		$@CurrentEvent = 0;
	} else {
		mapannounce .EnterMap$[3],"Ok the rules of "+.EventName$[3]+" are as follows",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"Each player picks a box 1, 2, 3 or 4",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"There will be a count down from 10 to 0",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"at 0 a four sided die will be rolled",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"Anyone in the box of the number rolled will be warped to town",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"as well as anyone on the stairs or outside the box",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"the number of players remaining will be announced",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"this prosses will repeat till only one player remains",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[3],"take a few moments to fnd a box",bc_blue;
		sleep 15000;
		mapannounce .EnterMap$[3],"we will now begin, please find a box",bc_blue;
		sleep 5000;
		for(.@1234 = 0; .@1234 < 100; .@1234++){
			for(.@i = 10; .@i > 0; .@i--){
				mapannounce .EnterMap$[3],.@i+"...",bc_blue;
				sleep 1000;
			}
			.@i = rand(1,4);
			$DiceCount[.@i]++;
			mapannounce .EnterMap$[3],"0... Good Bye Box "+.@i,bc_blue;
			switch(.@i){
				case 1:	areawarp .EnterMap$[3],183,81,191,58,"prontera",155,172;	break;
				case 2:	areawarp .EnterMap$[3],192,81,203,58,"prontera",155,172;	break;
				case 3:	areawarp .EnterMap$[3],204,81,215,58,"prontera",155,172;	break;
				case 4:	areawarp .EnterMap$[3],216,81,227,58,"prontera",155,172;	break;
			}
			areawarp .EnterMap$[3],0,0,183,400,"prontera",155,172;
			areawarp .EnterMap$[3],0,82,400,400,"prontera",155,172;
			areawarp .EnterMap$[3],0,58,400,0,"prontera",155,172;
			areawarp .EnterMap$[3],227,0,400,400,"prontera",155,172;
/*
			areawarp .EnterMap$[3],182,94,228,88,"prontera",155,172;	//Upper Area
			areawarp .EnterMap$[3],185,87,188,82,"prontera",155,172;	//Stairs 1
			areawarp .EnterMap$[3],197,87,200,82,"prontera",155,172;	//Stairs 2
			areawarp .EnterMap$[3],209,87,212,82,"prontera",155,172;	//Stairs 3
			areawarp .EnterMap$[3],221,87,224,82,"prontera",155,172;	//Stairs 4
*/
			if(getmapusers(.EnterMap$[3]) <= 1){
				.@1234 += 100;
			} else {
				mapannounce .EnterMap$[3],"There are "+getmapusers(.EnterMap$[3])+" Players Remaining.",bc_blue;
				mapannounce .EnterMap$[3],"Take a few moments if you want to change boxes.",bc_blue;
				sleep 20000;
			}
		}
		if(getmapusers(.EnterMap$[3])){
			addrid(5,0,.EnterMap$[3]);
			if(HP > 0 && strcharinfo(3) == .EnterMap$[3])
				Func_Prizes(getcharid(0),.EventName$[3]);
		}
		$@CurrentEvent = 0;
		mapwarp .EnterMap$[3],"prontera",155,172;
	}
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[5], .bombflag[.@i];
	end;

//==================================
OnPvPStart:	//-- PvP Event
//==================================

	killmonster .EnterMap$[4],"All";
	mapwarp .EnterMap$[4],"prontera",155,172;
	pvpoff .EnterMap$[4];
	$@CurrentEvent = 4;
	Func_Countdown;
	$@CurrentEvent = -4;
	.@count = getmapusers(.EnterMap$[4]);
	if(.@count < .MinPlayers[4]){
		mapannounce .EnterMap$[4],"Event Stopped! Not Enough Players Joined the "+.EventName$[4]+"!",bc_blue;
	} else {
		mapannounce .EnterMap$[4],"The Rules of "+.EventName$[4]+" are as follows",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[4],"This is a Free for all Last man Standing",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[4],"There is a 20 min time limit in place if there is no clear winner within 20 mins the Event ends",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[4],"Everyone has 1 Life so Res, Ygg Leafs and Kazail don't work",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[4],"Spread out PVP will begin in 10...",bc_blue;
		sleep 1000;
		for(.@i = 9; .@i > 0; .@i--){
			mapannounce .EnterMap$[4],.@i+"...",bc_blue;
			sleep 1000;
		}
		pvpon .EnterMap$[4];
		mapannounce .EnterMap$[4],"Begin",bc_blue;
		sleep 5000;
		freeloop(1);
		for(.@i = 1; .@i <= 360; .@i++){
			.@count[.@i] = getmapusers(.EnterMap$[4]);
			if(.@count[.@i] != .@count[.@i - 1]){
				if(.@count[.@i] < 2){
					.@i += 10000;
				} else	mapannounce .EnterMap$[4],"There are "+getmapusers(.EnterMap$[4])+" Players Remaining",bc_blue;
			}	
			sleep 5000;
		}
		freeloop(0);	
		if(getmapusers(.EnterMap$[4]) == 1){
			addrid(5,0,.EnterMap$[4]);
			if(HP > 0 && strcharinfo(3) == .EnterMap$[4])
				Func_Prizes(getcharid(0),.EventName$[4]);
		} else	mapannounce .EnterMap$[4],"Time Is up",bc_blue;
	}
	pvpoff .EnterMap$[4];
	$@CurrentEvent = 0;
	mapwarp .EnterMap$[4],"prontera",155,172;
	end;

//==================================
OnMazeStart:	//-- Maze Event
//==================================

	mapwarp .EnterMap$[5],"prontera",155,172;
	enablenpc "mazeroadblock";
	disablenpc "Event_Agent#Maze";
	$@CurrentEvent = 5;
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[5], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -5;
	sleep 9000;
	if(getmapusers(.EnterMap$[5]) < .MinPlayers[5])
		mapannounce .EnterMap$[5],"Event Stopped! Not Enough Players Joined the "+.EventName$[5]+"!",bc_blue;
	else {
		mapannounce .EnterMap$[5],"Rules are simple first to get to end of maze wins, so begin~",bc_blue;
		disablenpc "mazeroadblock";
		enablenpc "Event_Agent#Maze";
		for(.@maze = 40; .@maze > 0; .@maze--){
			if(getmapusers(.EnterMap$[5])<1) .@maze = 0;
			mapannounce .EnterMap$[5],"There are "+(.@maze)+" Minuets Remaining",bc_blue;
			sleep 60000;
		}
		mapannounce .EnterMap$[5],"Time Is up",bc_blue;
	}
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[5], .bombflag[.@i];
	disablenpc "Event_Agent#Maze";
	sleep 5000;
	mapwarp .EnterMap$[5],"prontera",155,172;
	$@CurrentEvent = 0;
	end;

//==================================
OnPoringStart:	//-- Poring Event
//==================================

	killmonsterall .EnterMap$[6];
	mapwarp .EnterMap$[6],"prontera",155,172;
	$@CurrentEvent = 6;
	pvpoff .EnterMap$[6];
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[6], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -6;
	if(getmapusers(.EnterMap$[6]) < .MinPlayers[6]){
		mapannounce .EnterMap$[6],"Event Stopped! Not Enough Players Joined the "+.EventName$[6]+"!",bc_blue;
	} else {
		killmonsterall .EnterMap$[6];
		mapannounce .EnterMap$[6],"Rules are simple",bc_blue;
		sleep 3000;
		mapannounce .EnterMap$[6],"Kill the 'Poring' with the correct name, and get a warped to town with a prize.",bc_blue;
		sleep 4000;
		mapannounce .EnterMap$[6],"Kill the wrong one and get warped to town with nothing.",bc_blue;
		sleep 4000;
		mapannounce .EnterMap$[6],"There are 2 right poring and a 30 min timer.",bc_blue;
		sleep 4000;
		mapannounce .EnterMap$[6],"Event will now Begin~",bc_blue;
		for(.@i = 0; .@i < getarraysize(.Poring$); .@i++)
			monster .EnterMap$[6],0,0,.Poring$[.@i],1725,5,strnpcinfo(3)+"::OnKillWrong";
		monster .EnterMap$[6],0,0,"--ja--",1725,.PoringSpawn,strnpcinfo(3)+"::OnKillRight";
		.PoringSpawn = 2;
 		for(.@poring = 30; .@poring > 0; .@poring--){
			if(getmapusers(.EnterMap$[6]) < 1)
				.@poring = 0;
			mapannounce .EnterMap$[6],callfunc("F_InsertPlural",.@poring,"Minute")+" Remaining.",bc_blue;
			sleep 60000;
		}
	}
	mapannounce .EnterMap$[6],"Time Is up",bc_blue;
	killmonsterall .EnterMap$[6];
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[6], .bombflag[.@i];
	$@CurrentEvent = 0;
	sleep 5000;
	mapwarp .EnterMap$[6],"prontera",155,172;
	end;

OnKillWrong:
	monster .EnterMap$[6],0,0,.Poring$[rand(1,getarraysize($@Mobs))],1725,1,strnpcinfo(3)+"::OnKillWrong";
	warp "prontera",155,172;
	end;

OnKillRight:
	Func_Prizes(getcharid(0),.EventName$[6]);
	.PoringSpawn -= 1;
	if(.PoringSpawn < 1){
		mapannounce .EnterMap$[6],"Time Is up",bc_blue;
		killmonsterall .EnterMap$[6];
		for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
			removemapflag .EnterMap$[6], .bombflag[.@i];
		$@CurrentEvent = 0;
		sleep 5000;
		mapwarp .EnterMap$[6],"prontera",155,172;
		end;
	}
	warp "prontera",155,172;
	end;

//==================================
OnLuckyStart:	//-- Lucky Event
//==================================

	$@CurrentEvent = 8;
	.luckywinner = 0;
	waitingroom "Lucky Event",99;
	Func_Countdown;
	getwaitingroomusers strnpcinfo(3);
	.luckywinner = .@waitingroom_users[rand(.@waitingroom_usercount)];
	$@CurrentEvent = -8;
	if(.@waitingroom_usercount >= .MinPlayers[8]){
		attachrid(.luckywinner);
		Func_Prizes(getcharid(0),.EventName$[8]);
	} else	announce .EventName$[8]+" Stopped! Not Enough Players Joined the "+.EventName$[8]+"!",bc_blue|bc_area|bc_npc;
	delwaitingroom;
	$@CurrentEvent = 0;
	.luckywinner = 0;
	end;

//==================================
OnBombStart:	//-- Bombring Event
//==================================

	mapwarp .EnterMap$[9],"prontera",155,172;
	$@CurrentEvent = 9;
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[9], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -9;
	.@totalplayers = getmapusers(.EnterMap$[9]);
	if(.@totalplayers < .MinPlayers[9]){
		mapannounce .EnterMap$[9],"Event Stopped! Not Enough Players Joined the "+.EventName$[9]+"!",bc_blue;
		mapwarp .EnterMap$[9],"prontera",155,172;
	} else {
		mapannounce .EnterMap$[9],"Okay listen up, this is how it works.",bc_blue;
		sleep 2000;
		mapannounce .EnterMap$[9],"Bombrings will run rampant in this area.",bc_blue;
		sleep 2000;
		mapannounce .EnterMap$[9],"and all of them will go booooooom!",bc_blue;
		sleep 2000;
		mapannounce .EnterMap$[9],"all you have to do is avoid them and stay alive :P",bc_blue;
		sleep 2000;
		mapannounce .EnterMap$[9],"This will run for 30 seconds for 5 total rounds.",bc_blue;
		sleep 2000;
		mapannounce .EnterMap$[9],"Sooooooooooo, ready or not here they come!!!",bc_blue;
		sleep 10000;
		for(.@wave = 1; .@wave <= .Bombwaves; .@wave++){
			if(.@wave < .Bombwaves){
				mapannounce .EnterMap$[9],"Wave "+.@wave+"!",bc_blue;
			} else	mapannounce .EnterMap$[9],"FIANL WAVE!",bc_blue;
			if (.@wave * .@totalplayers < 60)
				areamonster .EnterMap$[9],48,334,71,357,"Run for you life!",1904,.@wave * .@totalplayers;
			else	areamonster .EnterMap$[9],48,334,71,357,"Run for you life!",1904,60;
			if(!getmapusers(.EnterMap$[9]))
				.@wave += 5;
			else	sleep 1500 * .Bombwaves / .@wave;
		}
		sleep 10000;
		if(getmapusers(.EnterMap$[9]) > 0){
			addrid(5,0,.EnterMap$[9]);
			if(HP > 0 && strcharinfo(3) == .EnterMap$[9])
				Func_Prizes(getcharid(0),.EventName$[9]);
		}
		sleep 100;
	}
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[9], .bombflag[.@i];
	$@CurrentEvent = 0;
	mapwarp .EnterMap$[9],"prontera",155,172;
	end;

//==================================
OnHuntStart:	//-- Man Hunt Event
//==================================

	mapwarp .EnterMap$[10],"prontera",155,172;
	$@CurrentEvent = 10;
	Func_Countdown;
	$@CurrentEvent = -10;
	if(getmapusers(.EnterMap$[10]) < .MinPlayers[10]){
		mapannounce .EnterMap$[10],"Event Stopped! Not Enough Players Joined the "+.EventName$[10]+"!",bc_blue;
	} else {
		mapannounce .EnterMap$[10],"The goal is this event is to kill the target within 60 seconds.",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[10],"The one who managed to kill the target will gain a prize",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[10],"But if the target surivived, the target will gain the prize",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[10],"Man-Hunt Event start!",bc_blue;
		for(.@round = 1; .@round <= 5; .@round++){
			if(getmapusers(.EnterMap$[10]) < 3){
				mapannounce .EnterMap$[10],"Sorry there are no longer enough players for another round",bc_blue;
			} else {
				if(.@round < 5)
					mapannounce .EnterMap$[10],"Next Round will begin in 10 seconds!",bc_blue;
				for(.@i = 0; .@i < 10; .@i++){
					if($@LastTarget == $@Target)
						$@Target = .register_aid[rand(.register_count)];
					else break;
				}
				$@Targetname$ = rid2name($@Target);
				sleep 10000;
				mapannounce .EnterMap$[10],"[Round "+.@round+"] Our target is "+$@Targetname$+"!",bc_blue;
				attachrid($@Target);
				atcommand "#killable \""+$@Targetname$+"\"";
				atcommand "#size \""+$@Targetname$+"\" 2";
				detachrid;
				sleep 60000;
				if($@Target != -1){
					if(attachrid($@Target) && strcharinfo(3) == .EnterMap$[10])
						Func_Prizes(getcharid(0),.EventName$[10]);
				}
				attachrid($@Target);
				atcommand "#alive \""+$@Targetname$+"\"";
				atcommand "#killable \""+$@Targetname$+"\"";
				atcommand "#size \""+$@Targetname$+"\" 0";
				detachrid;
				$@LastTarget = $@Target;
			}
		}
	}
	sleep 5000;
	mapwarp .EnterMap$[10],"prontera",155,172;
	$@CurrentEvent = 0;
	end;

//==================================
OnShroomStart:	//-- Mushroom Event
//==================================

	.Map$ = .ShroomMaps$[rand(getarraysize(.ShroomMaps$))];
	killmonster .Map$,strnpcinfo(3)+"::OnShroomKilled";
	$@CurrentEvent = 11;
	.EnterMap$[$@CurrentEvent] = .Map$;
	Func_Countdown;
	$@CurrentEvent = -11;
	.@Spawn = .Spawn = max(1,rand(getusers(1) / 10));
	if(1 > .Spawn)
		.@Spawn = .Spawn = 1;
	monster .Map$,0,0,"Please don't kill me!",1084,.Spawn,strnpcinfo(3)+"::OnShroomKilled";
	announce "Find the Mushroom : Total of "+.Spawn+" Mushrooms have been spawned in "+.Map$+"!",bc_blue;
	sleep 60000 * 30;
	if(.Spawn == .@Spawn)
		announce .EventName$[11]+" Has Ended with No Winner!",bc_blue;
	killmonster .Map$,strnpcinfo(3)+"::OnShroomKilled";
	$@CurrentEvent = 0;
	end;

OnShroomKilled:
	if($@CurrentEvent == -11){
		.Spawn -= 1;
		Func_Prizes(getcharid(0),.EventName$[11]);
		if (.Spawn)
			announce "[ "+strcharinfo(0)+" ] has killed a Mushroom. There are now "+.Spawn+" Mushroom(s) left.",bc_map|bc_blue;
		else {
			announce .EventName$[11]+" has ended. All the Mushrooms have been killed.",bc_blue;
			$@CurrentEvent = 0;
		}
	}
	end;

//==================================
OnBaphoStart:	//-- Find the Baphomet
//==================================

	.Map$ = .BaphoMaps$[rand(getarraysize(.BaphoMaps$))];
	killmonster .Map$,strnpcinfo(3)+"::OnBaphoKilled";
	$@CurrentEvent = 12;
	.EnterMap$[$@CurrentEvent] = .Map$;
	Func_Countdown;
	$@CurrentEvent = -12;
	.@Spawn = .Spawn = 1;
	monster .Map$,0,0,"Please don't kill me!",1039,.Spawn,strnpcinfo(3)+"::OnBaphoKilled";
	announce "Find the Baphomet: Total of "+.Spawn+" Baphomets have been spawned in "+.Map$+"!",bc_blue;
	sleep 60000 * 30;
	if(.Spawn == .@Spawn)
		announce .EventName$[12]+" Has Ended with No Winner!",bc_blue;
	killmonster .Map$,strnpcinfo(3)+"::OnBaphoKilled";
	$@CurrentEvent = 0;
	end;

OnBaphoKilled:
	if($@CurrentEvent == -12){
		.Spawn -= 1;
		Func_Prizes(getcharid(0),.EventName$[12]);
		if (.Spawn)
			announce "[ "+strcharinfo(0)+" ] has killed a Baphomet. There are now "+.Spawn+" Baphomet(s) left.",bc_map|bc_blue;
		else {
			announce .EventName$[-$@CurrentEvent]+" has ended. All the Baphomets have been killed.",bc_blue;
			$@CurrentEvent = 0;
		}
	}
	end;

//==================================
OnCandyStart:	//-- Grab the Candy
//==================================

	mapwarp .EnterMap$[13],"prontera",155,172;
	$@CurrentEvent = 13;
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[16], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -13;
	if(getmapusers(.EnterMap$[13]) < .MinPlayers[13]){
		mapannounce .EnterMap$[13],"Event Stopped! Not Enough Players Joined the "+.EventName$[13]+"!",bc_blue;
	} else {
		sleep 3000;
		mapannounce .EnterMap$[13],"The goal is this event is to pick up as many "+getitemname(.candy_id)+" and as little "+getitemname(.apple_id)+" as possible.",bc_blue;
		sleep 1000;
		for ( .@i = 5; .@i >= 0; .@i-- ) {
			mapannounce .EnterMap$[13], "["+ .@i +"]",bc_blue;
			sleep 1000;
		}
		.@drop_candy_amount = .register_count * 25; // drop the amount of candies equal to no. of participants x 12
		freeloop 1;
		while ( .@i < .@drop_candy_amount / 2 ) {
			while ( checkcell( .EnterMap$[13], .@x = rand(450), .@y = rand(450), cell_chknopass ) );
				makeitem .candy_id, 1, .EnterMap$[13], .@x, .@y;
			.@i++;
		}
		.@i = 0;
		while ( .@i < 800 ) {
			while ( checkcell( .EnterMap$[13], .@x = rand(450), .@y = rand(450), cell_chknopass ) );
			if(rand(2))
				makeitem .candy_id, 1+rand(3)*rand(3), .EnterMap$[13], .@x, .@y;
			else
				makeitem .apple_id, 1+rand(2)*rand(2), .EnterMap$[13], .@x, .@y;
			.@i++;
			sleep 75;
		}
		freeloop 0;
		for ( .@i = 0; .@i < .register_count; .@i++ ) {
			if ( attachrid( .register_aid[.@i] ) ) {
				.@amount = countitem( .candy_id );
				.@amount -= countitem( .apple_id );
				if ( .@amount >= .@highest ) {
					setd ".@count"+ .@amount +"["+ getarraysize( getd( ".@count"+ .@amount ) ) +"]", getcharid(3);
					.@highest = .@amount;
				}
				dispbottom "Candy: "+countitem( .candy_id)+" Apples: "+ countitem( .apple_id );
				delitem .candy_id, countitem( .candy_id );
				delitem .apple_id, countitem( .apple_id );
			}
		}
		cleanmap .EnterMap$[13];
		if ( .@size = getarraysize( getd( ".@count"+ .@highest ) ) ) {
			for ( .@i = 0; .@i < .@size; .@i++ ) {
				attachrid getd( ".@count"+ .@highest +"["+ .@i +"]" );
				Func_Prizes(getcharid(0),.EventName$[13]);
			}
			mapannounce .EnterMap$[13], "Event end, there are "+ .@size +" player having most "+ getitemname( .candy_id ) +" with "+.@highest+"! "+ .@name$,bc_blue;
		} else	mapannounce .EnterMap$[13], "Event end, nobody is a winner ... too bad", 0;
	}
	sleep 5000;
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[16], .bombflag[.@i];
	mapwarp .EnterMap$[13],"prontera",155,172;
	deletearray .register_aid;
	.register_count = 0;
	$@CurrentEvent = 0;
	end;

//==================================
OnCountStart:	//-- Monsters Counting
//==================================

	killmonster .EnterMap$[14],strnpcinfo(3)+"::OnKilled";
	$@CurrentEvent = 14;
	Func_Countdown;
	.Round = .CountRound;

OnStartCountRound:
	for(.@i = 0; .@i < getarraysize( .CountMonster ); .@i++)
		.MobCount[.@i] = 0;
	for( .@x = .CountXY[0]; .@x <= .CountXY[2]; .@x++ ){
		for( .@y = .CountXY[1]; .@y <= .CountXY[3]; .@y++ ){
			.@Summon = rand( getarraysize( .CountMonster ) );
			monster .EnterMap$[14],.@x,.@y,"Count Me",.CountMonster[.@Summon],1,strnpcinfo(3)+"::OnKilled";
			.GID = $@mobid;
			setunitdata .GID,UMOB_DMGIMMUNE,1;
			.MobCount[.@Summon]++;
			sleep 1;
		}
	}
	.Target = rand( getarraysize( .CountMonster ) );
	deletepset 1;
	defpattern 1, "([^:]+): (\\|\\d{2})?"+.MobCount[.Target]+ ".$", "OnRightCount";
	defpattern 1,"([^:]+):.*.*", "OnSpam";
	activatepset 1;
	delwaitingroom;
	waitingroom getmonsterinfo( .CountMonster[.Target],0 ),0;
	npctalk "Count for the Targeted Monster's Amount to Win the Game.";
	$@CurrentEvent = -14;
	initnpctimer;
	end;

OnSpammed:
	@Spam = 0;
	end;

OnSpam:
	if( getgmlevel() > 90 ) end;
	@Spam++;
	if( @Spam >= .Spam ){	// 3 Continuos Answer will trigger...
		@SpamDelay = gettimetick(2) + .Spam;
		dispbottom "SPAM Detected, your answer within next "+.Spam+" Seconds will be Ignored.";
	}
	deltimer strnpcinfo(3)+"::OnSpammed";
	addtimer ( .Spam * 1000 ),strnpcinfo(3)+"::OnSpammed";
	end;

OnRightCount:
	@Spam = 0;
	deltimer strnpcinfo(3)+"::OnSpammed";
	if( $@CurrentEvent != -14 && $@CurrentEvent != -18 ){
		message strcharinfo(0),"Sorry, there is no Event right now.";
	} else if( @SpamDelay > gettimetick(2) ){
		message strcharinfo(0),"SPAM Protection : Remain "+( @SpamDelay - gettimetick(2) )+" seconds.";
	} else if( getcharid(0) == .Winner[0] && gettimetick(2) < .Winner[1] ){
		message strcharinfo(0),"Sorry, Winner Time Penalty : Remain "+( .Winner[1] - gettimetick(2) )+" seconds.";
	} else {
		delwaitingroom;
		$@CurrentEvent = 14;
		.Round--;
		.Winner[0] = getcharid(0);
		.Winner[1] = gettimetick(2) + .Delay;
		deletepset 1;
		Func_Prizes(getcharid(0),.EventName$[14]);
		killmonster .EnterMap$[14],strnpcinfo(3)+"::OnKilled";
		if( .Round )
			donpcevent strnpcinfo(3)+"::OnStartCountRound";
		else	$@CurrentEvent = 0;

	}
	end;

OnKilled:
	end;

//==================================
OnDisguiseStart: //-- Disguise
//==================================

	mapwarp .EnterMap$[15],"prontera",155,172;
	$@CurrentEvent = 15;
	Func_Countdown;
	$@CurrentEvent = -15;
	.Round = .DisguiseRound;
	sleep 9000;
	if(getmapusers(.EnterMap$[15]) < .MinPlayers[15])
		mapannounce .EnterMap$[15],"Event Stopped! Not Enough Players Joined the "+.EventName$[15]+"!",bc_blue;
	else {
		enablenpc $@DisguiseNpc$;
		sleep 100;
		donpcevent "Disguise Event::OnStart";
		for(.@dis = 30; .@dis > 0; .@dis--){
			if(!getmapusers(.EnterMap$[15]))
				.@dis = 0;
			// mapannounce .EnterMap$[15],"There are "+(.@dis)+" Minuets Remaining",bc_blue;
			sleep 60000;
		}
		mapannounce .EnterMap$[15],"Time Is up",bc_blue;
	}
	disablenpc $@DisguiseNpc$;
	sleep 5000;
	mapwarp .EnterMap$[15],"prontera",155,172;
	$@CurrentEvent = 0;
	end;

//==================================
OnFabreStart:	//-- Fabre Event
//==================================

	killmonsterall .EnterMap$[16];
	deletearray .register_aid;
	.register_count = 0;
	mapwarp .EnterMap$[16],"prontera",155,172;
	$@CurrentEvent = 16;
	pvpoff .EnterMap$[16];
	for ( .@i = 0; .@i < getarraysize( .bombflag ); .@i++ )
		setmapflag .EnterMap$[16], .bombflag[.@i];
	Func_Countdown;
	$@CurrentEvent = -16;
	if(getmapusers(.EnterMap$[16]) < .MinPlayers[16]){
		mapannounce .EnterMap$[16],"Event Stopped! Not Enough Players Joined the "+.EventName$[16]+"!",bc_blue;

		$@CurrentEvent = 0;
	} else {
		killmonsterall .EnterMap$[16];
		mapannounce .EnterMap$[16],"Rules are simple",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[16],"Kill the monsters to recive points.",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[16],"Player with the most points at the end wins.",bc_blue;
		sleep 5000;
		mapannounce .EnterMap$[16],"Event will now Begin~",bc_blue;
		monster .EnterMap$[16],0,0,"1 Point",1007,90,strnpcinfo(3)+"::OnKill_1";
		monster .EnterMap$[16],0,0,"3 Point",1008,30,strnpcinfo(3)+"::OnKill_2";
		monster .EnterMap$[16],0,0,"-2 Point",1002,70,strnpcinfo(3)+"::OnKill_3";
 		for(.@fabre = 6; .@fabre > 0; .@fabre--){
			if(getmapusers(.EnterMap$[16]) < 1) .@fabre = 0;
				mapannounce .EnterMap$[16],callfunc("F_InsertPlural",(.@fabre*10),"Second")+" Remaining.",bc_blue;
			if(.TestMode)
				sleep 5000;
			else
				sleep 10000;
		}
		killmonsterall .EnterMap$[16];
		for ( .@i = 0; .@i < .register_count; .@i++ ) {
			if ( attachrid( .register_aid[.@i] ) ) {
				.@amount = fabre;
				if ( .@amount >= .@highest ) {
					setd ".@count"+ .@amount +"["+ getarraysize( getd( ".@count"+ .@amount ) ) +"]", getcharid(3);
					.@highest = .@amount;
				}
				dispbottom "Score: "+fabre;
				fabre = 0;
			}
		}
		if ( .@size = getarraysize( getd( ".@count"+ .@highest ) ) ) {
			for ( .@i = 0; .@i < .@size; .@i++ ) {
				attachrid getd( ".@count"+ .@highest +"["+ .@i +"]" );
				Func_Prizes(getcharid(0),.EventName$[16]);
			}
			mapannounce .EnterMap$[16], "Event end, there are "+ .@size +" player having "+.@highest+" Points ! "+ .@name$,bc_blue;
		} else	mapannounce .EnterMap$[16], "Event end, nobody is a winner ... too bad", 0;
		
	}
	for ( .@i = 6; .@i < getarraysize( .bombflag ); .@i++ )
		removemapflag .EnterMap$[16], .bombflag[.@i];
	mapwarp .EnterMap$[13],"prontera",155,172;
	deletearray .register_aid;
	.register_count = 0;
	$@CurrentEvent = 0;
	end;
		
OnKill_1:
	monster .EnterMap$[16],0,0,"1 Point",1007,1,strnpcinfo(3)+"::OnKill_1";
	fabre += 1;
	end;
		
OnKill_2:
	monster .EnterMap$[16],0,0,"3 Points",1008,1,strnpcinfo(3)+"::OnKill_2";
	fabre += 3;
	end;
		
OnKill_3:
	monster .EnterMap$[16],0,0,"-2 Points",1002,1,strnpcinfo(3)+"::OnKill_3";
	fabre -= 2;
	end;

//==================================
OnDevilStart:	//-- Devil Square
//==================================

	killmonsterall .EnterMap$[17];
	mapwarp .EnterMap$[17],"prontera",155,172;
	pvpoff .EnterMap$[4];
	for ( .@i = 0; .@i < getarraysize( .devilflag ); .@i++ )
		setmapflag .EnterMap$[17], .devilflag[.@i];
	$@CurrentEvent = 17;
	Func_Countdown;
	$@CurrentEvent = -17;
	$MVPdefeat = 0;
	killmonsterall .EnterMap$[17];
	sleep 9000;
	if(getmapusers(.EnterMap$[17]) < .MinPlayers[17])
		mapannounce .EnterMap$[17],"Event Stopped! Not Enough Players Joined the "+.EventName$[17]+"!",bc_blue;
	else {
		mapannounce .EnterMap$[17],"[Devil Square]: You will encounter 3 waves of monsters. The monsters will grow stronger with each wave.",bc_blue;
		mapannounce .EnterMap$[17],"[Devil Square]: If you defeat all the enemies, you will be given the opportunity to open 10 Treasure Chests with items, equipment, and rare cards inside!",bc_blue;
		mapannounce .EnterMap$[17],"[Devil Square]: Event has started!",bc_blue;
		.round = 0;
		.mob = 0;
		set .monsterset, query_sql("SELECT id, iname, hp FROM `mob_db` where LV <= 70 and LV >= 60 and hp < 99999999 and MEXP = 0 and not iName='Treasure Chest' ORDER BY RAND() LIMIT 100", .monsterid, .monstername$, .monsterhp);
		for (.@x = 0; .@x < min(10,getmapusers(.EnterMap$[17])); .@x++){
			.monstercount = 3;
			for (.@y = 0; .@y < 3; .@y++) {
				.monster = rand(0,.monsterset-1);
				monster .EnterMap$[17],0,0,"[Devil Square]: "+.monstername$[.monster],.monsterid[.monster],.monstercount,strnpcinfo(3)+"::OnDevilDead";	 
				.mob += .monstercount;
			}
		}
		for(.devil = 50; .devil > 0; .devil--){
			if(getmapusers(.EnterMap$[17]) < 1){
				.devil = .round = .mob = $@CurrentEvent = 0;
			}
			mapannounce .EnterMap$[17],"There are "+(.devil)+" Minuets Remaining",bc_blue;
			sleep 60000;
		}
		mapannounce .EnterMap$[17],"Time Is up",bc_blue;
	}
	$@CurrentEvent = 0;
	killmonsterall .EnterMap$[17];
	for ( .@i = 6; .@i < getarraysize( .devilflag ); .@i++ )
		removemapflag .EnterMap$[17], .devilflag[.@i];
	sleep 5000;
	mapwarp .EnterMap$[17],"prontera",155,172;
	end;
 
OnDevilDead:
	if(.round > 3){
		$MVPDefeat += 5;
		if (rand(1,2 + $MVPDefeat) == 1) { 
			mapannounce .EnterMap$[17],"[Devil Square]: It's not over yet! Another MVP Has entered the realm!!", bc_map;
			set .mob, 0;
			if (getmapusers(.EnterMap$[17]) <= 5)
				set .monsterset, query_sql("SELECT id, iname FROM `mob_db` where LV <= 99 and LV >= 1 and MEXP>1", .monsterid, .monstername$);
			else
				set .monsterset, query_sql("SELECT id, iname FROM `mob_db` where LV <= 99 and LV >= 85 and MEXP>1", .monsterid, .monstername$);
			.monstercount = 1;
			.monster = rand(0,.monsterset-1);
			monster .EnterMap$[17],0,0,"[Devil Square]: "+.monstername$[.monster],.monsterid[.monster],1,strnpcinfo(3)+"::OnDevilDead";
		} else {
			mapannounce .EnterMap$[17],"The Devil Square has been eradicated!", bc_map;
			mapannounce .EnterMap$[17],"Treasure chests have appeared across the map!", bc_map;
			.round++;
			set .monsterset, query_sql("SELECT id FROM `mob_db`  where iName='Treasure Chest';", .monsterid);
			for(.@x = 0; .@x < getmapusers(.EnterMap$[17]); .@x++){
				monster .EnterMap$[17],0,0,"[Devil Square]: "+.monstername$[.monster],.monsterid[.monster],1,strnpcinfo(3)+"::OnTreasureDead";	 
				.mob++;
			}
		}
		end; 
	} else {
		.mob -= 1;
		if (.mob >= 1){
			announce "Devil Square : "+ .mob +" monsters remaining in round "+.round+".", bc_map;
		} else {
			if(.round == 3){
				mapannounce .EnterMap$[17],"[Devil Square]: Watchout!! An MVP Has entered the realm!!", bc_map;	
				.mob =  0;
				if (getmapusers(.EnterMap$[17]) <= 5)
					set .monsterset, query_sql("SELECT id, iname FROM `mob_db` where LV <= 99 and LV >= 1 and MEXP>1", .monsterid, .monstername$);
				else
					set .monsterset, query_sql("SELECT id, iname FROM `mob_db` where LV <= 99 and LV >= 85 and MEXP>1", .monsterid, .monstername$);
				.monstercount = 1;
				.monster = rand(0,.monsterset-1);
				monster .EnterMap$[17],0,0,"[Devil Square]: "+.monstername$[.monster],.monsterid[.monster],1,strnpcinfo(3)+"::OnDevilDead";
				.round++;
			} else {
				mapannounce .EnterMap$[17],"[Devil Square]: Entering round "+(.round + 1)+" in 30 seconds", bc_map;
				sleep 20000;
				mapannounce .EnterMap$[17],"[Devil Square]: Entering round "+(.round + 1)+" in 10 seconds.", bc_map;
				sleep 5000;
				mapannounce .EnterMap$[17],"[Devil Square]: Entering round "+(.round + 1)+" in 5 seconds.", bc_map;
				sleep 5000;		    
				.round++;
				.mob = 0;
				.@lvmin = 65 + .round * 5;
				.@lvmax = .@lvmin + 5;
				set .monsterset, query_sql("SELECT id, iname, hp FROM `mob_db` where LV <= "+.@lvmax+" and LV >= "+.@lvmin+" and hp < 99999999 and MEXP = 0 and not iName='Treasure Chest' ORDER BY RAND() LIMIT 100", .monsterid, .monstername$, .monsterhp);
				for(.@x = 0; .@x < getmapusers(.EnterMap$[17]); .@x++){
					.monstercount = 3;
					for(.@y = 0; .@y < .monstercount; .@y++) {
						.monster = rand(0,.monsterset-1);
						monster .EnterMap$[17],0,0,"[Devil Square]: "+.monstername$[.monster],.monsterid[.monster],.monstercount,strnpcinfo(3)+"::OnDevilDead";	 
						.mob += .monstercount;
					}
				}
			}
		}
	}
	end;
 
OnTreasureDead:
	.mob -= 1;
	if (.mob < 1){
		.round = .mob = .devil = 0;
		addrid(5,0,.EnterMap$[17]);
		Func_Prizes(getcharid(0),.EventName$[17]);
		sleep2 10000;
		warp "prontera",155,172;
	}
	$@CurrentEvent = 0;
	end;

//==================================
OnSongStart:	//-- Name that BGM
//==================================

	$@CurrentEvent = 18;
	Func_Countdown;
	.Round = .SongRound;

OnStartSongRound:
	.SongID = 0;
	while(!.SongID || .SongID == 32)
		.SongID = rand(1,getarraysize(.SongName$));
	deletepset 1;
	defpattern 1, "([^:]+): (\\|\\d{2})?"+ .SongName$[.SongID] + ".$", "OnRightSong";
	defpattern 1,"([^:]+):.*.*", "OnSpam";
	activatepset 1;
	delwaitingroom;
	waitingroom .EventName$[18],0;
	npctalk "Name the BGM to win~.";
	$@CurrentEvent = -18;
	initnpctimer;
	.@round = .Round;
	while(.Round && .@round == .Round && $@CurrentEvent == -18){
		.@song$ = "";
		if(.SongID < 10) .@song$ = "0";
		.@song$ += .SongID;
		playBGMall .@song$,.EnterMap$[18];
		sleep .SongTime[.SongID];
	}
	end;

OnRightSong:
	@Spam = 0;
	deltimer strnpcinfo(3)+"::OnSpammed";
	if( $@CurrentEvent != -18 ){
		message strcharinfo(0),"Sorry, there is no Event right now.";
	} else if( @SpamDelay > gettimetick(2) ){
		message strcharinfo(0),"SPAM Protection : Remain "+( @SpamDelay - gettimetick(2) )+" seconds.";
	} else if( getcharid(0) == .Winner[0] && gettimetick(2) < .Winner[1] ){
		message strcharinfo(0),"Sorry, Winner Time Penalty : Remain "+( .Winner[1] - gettimetick(2) )+" seconds.";
	} else {
		delwaitingroom;
		.Round--;
		.Winner[0] = getcharid(0);
		.Winner[1] = gettimetick(2) + .Delay;
		deletepset 1;
		Func_Prizes(getcharid(0),.EventName$[18]);
		if( .Round )
			donpcevent strnpcinfo(3)+"::OnStartSongRound";
		else	$@CurrentEvent = 0;
	}
	end;

//==================================
OnPCLogOutEvent:	//-- On Logout
//==================================

	if($@CurrentEvent == -10 && getcharid(3) == $@Target){
		mapannounce .EnterMap$[10],"The target has logged out of this game. This round will be nulled.",bc_blue;
		$@Target = -1;
	} else if($@CurrentEvent == -13 || $@CurrentEvent == 13){
		for(.@i = 0; .@i < .register_count; .@i++)
			if(getcharid(3) == .register_aid[.@i])
				deletearray .register_aid[.@i], 1;
	}
	end;

//==================================
OnPCDieEvent:	//-- On player death
//==================================
	if(isequipped(51055))
		DracoFail++;
	if(($@CurrentEvent == -4 && strcharinfo(3) == .EnterMap$[4]) || ($@CurrentEvent == -2 && strcharinfo(3) == .EnterMap$[2]))
		warp "prontera",155,172;
	if($@CurrentEvent == -10 && getcharid(3) == $@Target ){
		Func_Prizes(getcharid(0,rid2name(killerrid)),.EventName$[10]);
		$@Target = -1;
	}
	end;

//==================================
OnTimer1800000:	// Timer for Monster Count and Song
//==================================

	if($@CurrentEvent == -14 || $@CurrentEvent = -18 || $@CurrentEvent == 14 || $@CurrentEvent = 18){
		if($@CurrentEvent < 0)
			.@ce = -1 * $@CurrentEvent;
		mapannounce .EnterMap$[.@ce],"["+.EventName$[.@ce]+"]: Event has come to and end.", bc_map;	
		.Round = .SongID = .Target = $@CurrentEvent = 0;
		killmonster .EnterMap$[14],strnpcinfo(3)+"::OnKilled";
		$@CurrentEvent = 0;
		delwaitingroom;
		deletepset 1;
	}
	stopnpctimer;
	end;

//==================================
OnInit:		//-- Config
//==================================

// -------------------
//  Rewards
// -------------------

	// Recive rewards via
	// [0] = Direct to inv
	// [1] = Mail / RoDex
	$@Mail = 1;	

	// Does not support multiple item rewards
	// Rewards are Mailed to winners
	// Ro Dex Supports 5 Items
	// Old Mail & Direct DO NOT support multiple items
	setarray $@RewardID	,33001,0,0,0,0;
	setarray $@RewardQNT	,    1,0,0,0,0;
	$@RewardZeny = 10000;

	// Not Adding Card / Random Bonus Support Yet, bug me if you really want it.

// -------------------
//  Ranking
// -------------------

	// Enable Event Ranking
	// Bitwise
	// [1] = Liftime
	// [2] = Mothly
	// [3] = Both
	$@EventRanking = 3;

// -------------------
//  At Commands
// -------------------

	// Run Event Command to manually run event
	bindatcmd("runevent",strnpcinfo(3)+"::OnRunEvent",60,99);

	// End Event Command to manually end event
	bindatcmd("stopevent",strnpcinfo(3)+"::OnEndEvent",60,99);

	// Randomize Event Command to randomize event scedule
	bindatcmd("randevent",strnpcinfo(3)+"::OnRandomize",60,99);

	// Clear Event Command to wipe event scedule
	bindatcmd("wipeevent",strnpcinfo(3)+"::OnClear",60,99);

	// Remove Event Command to wipe event scedule
	bindatcmd("removeevent",strnpcinfo(3)+"::OnRemoveType",60,99);

	// Add Event Command to wipe event scedule
	bindatcmd("addevent",strnpcinfo(3)+"::OnRemoveType",60,99);

	// Debugmode Toggle Command
	bindatcmd("testevent",strnpcinfo(3)+"::OnTestMode",60,99);

	// Join Event Command
	bindatcmd("joinevent",strnpcinfo(3)+"::OnJoinEvent",0,99);
	bindatcmd("join",strnpcinfo(3)+"::OnJoinEvent",0,99);
	bindatcmd("je",strnpcinfo(3)+"::OnJoinEvent",0,99);

// -------------------
//  Event Data
// -------------------

	// Gm Level to access GM Menus
	.GMAccess = 99;

	// How Many Mins after the hour till event starts
	// Don't forget 5 mins for Func_Countdown
	.StartTime = 25;

	// Event Names
	setarray .EventName$[1],
		"Emperium Event","Zombie Survival","Dice Event","PvP Event","Maze Event",
		"Find The Poring","Cluckers","Lucky Pick","Bombring Event","Manhunt",
		"Find The Mushroom","Find The Baphomet","Grab the Candy!","Monsters Counting","Disguise Event",
		"Fabre Event","Devil Square","What's the BGM";

	// Colored Event Names
	setarray .ColorName$[1],
		"^00CCCC"+.EventName$[1]+"^000000",	"^CC00CC"+.EventName$[2]+"^000000",	"^00CC00"+.EventName$[3]+"^000000",	"^CC0000"+.EventName$[4]+"^000000",	"^00CC00"+.EventName$[5]+"^000000",
		"^00CCCC"+.EventName$[6]+"^000000",	"^00CC00"+.EventName$[7]+"^000000",	"^00CC00"+.EventName$[8]+"^000000",	"^CC00CC"+.EventName$[9]+"^000000",	"^CC0000"+.EventName$[10]+"^000000",
		"^00CCCC"+.EventName$[11]+"^000000",	"^00CCCC"+.EventName$[12]+"^000000",	"^00CC00"+.EventName$[13]+"^000000",	"^00CC00"+.EventName$[14]+"^000000",	"^00CC00"+.EventName$[15]+"^000000",
		"^00CCCC"+.EventName$[16]+"^000000",	"^CC00CC"+.EventName$[17]+"^000000",	"^00CCCC"+.EventName$[18]+"^000000";

	// Min Players
	//	Cluckers, Mushroom & Monter Counting don't check
	setarray .MinPlayers[1],
		2,1,2,3,2,
		1,0,3,1,4,
		0,0,2,0,3,
		3,3,0;

	// @JoinEvent warp points
	setarray .EnterMap$[1],
		"prontera","1@zombie","quiz_01","pvp_n_1-5","maze",
		"pvp_n_1-5","prontera","prontera","quiz_02","pvp_n_1-5",
		"prontera","prontera","pvp_n_1-5","prontera","pvp_n_1-5",
		"pvp_n_1-5","pvp_n_1-5","prontera";

	setarray .EnterX[1],
		161,  0,205,  0,371,
		  0,155,161, 59,  0,
		  0,  0,  0,157,  0,
		  0, 100,156;

	setarray .EnterY[1],
		168,  0, 92,  0,143,
		  0,227,168,345,  0,
		  0,  0,  0,171,  0,
		  0, 100,164;

	// Zombies Spawned per Wave
	// MobID1,Quantity1{,MobID2,Quantity2{,{....}}
	//	Quantity is multiplied by number of waves
	//	so 10 will become 100 in last wave
	//	and mobs are not killed between
	//	so 10 will have 550 spawned in last wave
	setarray .Zombies,25155,10,1423,5,1298,1;

	// Fake Poring Names
	setarray .Poring$,	"Porjng","P0ring","Porlng","Porimg","Porinq",
				"Poporing","This One","Right","Kill Me","Poning",
				"qoring","Pooring","Pouring","Polling","~Poring~",
				"Winner","Prize","Porirg","Paring","Notice Me Senpai",
				"Pickle","Puring","Ponirg","Poning","P o r i n g";

	// Number of poring to Spawn in Find the poring Event
	.PoringSpawn = 2;

	// Poring and Bombring and Grab the Candy Mapflags
	setarray .bombflag,mf_nosave,mf_nowarp,mf_nowarpto,mf_nomemo,mf_noteleport,MF_NOITEMCONSUMPTION,MF_NOTRADE,mf_noreturn,mf_nobranch,mf_nomobloot,mf_nomvploot,mf_noskill,mf_noitemconsumption,mf_nodrop,mf_notrade,mf_nopenalty;

	// Devil Square Mapflags
	setarray .devilflag,mf_nosave,mf_nowarp,mf_nowarpto,mf_nomemo,mf_noteleport,mf_noreturn,mf_notrade,mf_nopenalty,mf_nobranch,mf_nodrop,mf_nomobloot,mf_nomvploot;

	// Mushroom Event Possible Maps
	setarray .ShroomMaps$,"izlude","geffen","morocc","prontera";

	// Baphomet Event Possible Maps
	setarray .BaphoMaps$,"splendide","hugel","yuno","comodo","xmas","aldebaran","izlude","payon","geffen","morocc","prontera";

	// Number of waves in Bombporing Event
	.Bombwaves = 6;

	// Item ID used in the Grab the Candy! event
	// Best to use a custom ID
	.candy_id = 529;

	// Item ID used in the Grab the Candy! event
	// Best to use a custom ID
	.apple_id = 7821;
	
	// Monster Counting
	setarray .CountMonster,1084,1085;

	// Number of rounds for Monster Counting
	.CountRound = 3;

	// Number of rounds for Whats the BGM
	.SongRound = 3;

	// Monster Coutning Mob Spawn area
	setarray .CountXY,152,160,159,167;

	// Winners Answer Delay for Monster Counting
	set .Delay,1800;

	// Spam Prevention for Monster Counting
	set .Spam,3;

	setarray .SongName$[1],	"Title", "Gambler of highway", "Peaceful Forest", "I miss you", "Tread on the ground", "Risk your life", "Wind of Tragedy", "Theme of Prontera", "Great honor", "Divine Grace", 
			"Theme of Morroc", "Streamside", "Theme of Geffen", "Theme of Payon", "Theme of Alberta", "Labyrinth", "Tresure hunter", "Time up!!", "Under the ground", "Ancient groover", 
			"Through the tower", "Backattack!!", "Travel", "Desert", 
			"Plateau", "Everlasting Wanderers", "Dreamer's Dream", "You're in ruins", "Be Nice 'n Easy", "One Step Closer", 
			"Brassy Road", "", "Yuna Song", "Pampas Upas", "TeMPoison", "Nano East", "TeMPorsche", "Hamatan", "Theme of Al de Baran", "Fear...", 
			"Rag All Night Long", "Curse'n Pain", "Morning Gloomy", "TeMP it Up", "Don't Piss me Off", "An Ant-lion's Pit", "Welcome Mr.Hwang", "Help Yourself", "Watery Grave", "Out of Curiosity", 
			"Believe in myself", "Ready~", "White Christmas", "Come on my deer!!", "Welcome, my lord", "Silver Bell", "Don't cry, baby", "Jingle Bell on Ragnarok", "Theme of Lutie", "Aeon", 
			"Zingaro", "High Roller Coaster", "Mucho Gusto", "One Fine Day", "Into the Abyss", "Wanna Be Free!!", "TeMPotato", "Jazzy Funky Sweety", "Retro Metro", "Theme of Juno", 
			"Antique Cowboy", "Big Guys Love This", "Higher than the sun", "Not so far away", "Come, and Get It!", "Purity of your smile", "Can't go home again, baby", "adios", "The Great", "Jumping Dragon", 
			"Thai Orchid", "Muay Thai King", "Sleepless", "Christmas in the 13th Month", "Dancing Christmas in the 13th Month", "Steel Me", "Ethnica", "Come in Peace", "We have Lee but you don't have", "Noblesse Oblige", 
			"CheongChoon", "Naive Rave", "Latinnova", "Theme of Rael", "Underneath The Temple", "Yetit Petit", "Lastman Dancing", "Top Hoppy", "Uncanny Lake", "Abyss",
			"AbSolitude", "Erebos' Prelude", "Invisible Invasion", "On Your Way Back", "Rose of Sharon", "Sleeping Volcano", "Seven Days Seven Nights", "Angelica", "Alpen Rose", "Kingdom Memories", 
			"Good Morning", "Good Night", "Monastery In Disguise", "Theme of Moscovia", "Tale of the East", "Away from Home", "Dream of a Whale", "Taiko's Fury", "Stained Memories", "Fissure Eruption", 
			"Outer Breath", "Ethical Aspiration", "Into The Arena!", "Stranger Aeons", "Forbidden Anguish", "New World Orde", "Mystic Haze", "Splendide Dreams", "Fireflies Heaven", "Dread and Bold", 
			"Daytime in Manuk", "March with Irish Whistle", "Sunny Side of Life", "Borborema", "At Dusk", "Emotion Creep", "Dazzling Snow", "TeMPlatonic", "Sugar Cane Carnival", "Twilight Heaven", 
			"Tricky Cheeky", "Arrival", "Mother Earth", "Silent Voyage", "Marshmallow Waltz", "Diamond Dust", "Octopus Scamble", "Melt Down!", "Theme of Port Malaya", "Uncanny Dreams", 
			"Maximum", "Voices", "Horizon", "Eclage", "Eclage", "Beyond The Grave", "Disillusion", "Indelible Scars", "Judgement", "Jittering Nightmare",
			"Forest of Despiar", "Dark Light", "Lost souls", "From the Grave", "Apex Fortress", "Brutal Ritual", "Shade of a Shadow", "How to rescue our dragon", "Little kitty's adventure", "Welcome to Doram town",
			"Django vs Yojimbo", "Macaroni Express", "", "Ethnically Diverse", "Cat on Bullet", "Tears of Deviant", "mysterious mansion", "behind the silence", "Echoes of Nature", "Finding pillow book",
			"limits of darkness", "Cake Is Lie", "I Need You", "Magdaros", "Once upon a December", "Theme of Wolf";

	setarray .SongTime[1],	1 * 60000 + 14 * 1000,3 * 60000 + 03 * 1000,2 * 60000 + 30 * 1000,2 * 60000 + 46 * 1000,1 * 60000 + 54 * 1000,2 * 60000 + 49 * 1000,1 * 60000 + 44 * 1000,4 * 60000 + 33 * 1000,1 * 60000 + 19 * 1000,1 * 60000 + 36 * 1000,
				2 * 60000 + 08 * 1000,2 * 60000 + 27 * 1000,3 * 60000 + 00 * 1000,2 * 60000 + 22 * 1000,3 * 60000 + 20 * 1000,2 * 60000 + 18 * 1000,2 * 60000 + 36 * 1000,3 * 60000 + 44 * 1000,3 * 60000 + 22 * 1000,2 * 60000 + 04 * 1000,
				1 * 60000 + 41 * 1000,2 * 60000 + 06 * 1000,3 * 60000 + 23 * 1000,3 * 60000 + 40 * 1000,2 * 60000 + 36 * 1000,2 * 60000 + 09 * 1000,3 * 60000 + 20 * 1000,2 * 60000 + 26 * 1000,2 * 60000 + 26 * 1000,2 * 60000 + 59 * 1000,
				2 * 60000 + 48 * 1000,0 * 60000 + 00 * 1000,2 * 60000 + 23 * 1000,2 * 60000 + 35 * 1000,3 * 60000 + 08 * 1000,1 * 60000 + 55 * 1000,2 * 60000 + 23 * 1000,2 * 60000 + 25 * 1000,3 * 60000 + 45 * 1000,2 * 60000 + 30 * 1000,
				2 * 60000 + 35 * 1000,3 * 60000 + 03 * 1000,2 * 60000 + 20 * 1000,2 * 60000 + 10 * 1000,2 * 60000 + 22 * 1000,2 * 60000 + 11 * 1000,2 * 60000 + 20 * 1000,2 * 60000 + 38 * 1000,2 * 60000 + 30 * 1000,2 * 60000 + 18 * 1000,
				2 * 60000 + 12 * 1000,1 * 60000 + 43 * 1000,2 * 60000 + 09 * 1000,2 * 60000 + 09 * 1000,2 * 60000 + 00 * 1000,2 * 60000 + 01 * 1000,2 * 60000 + 04 * 1000,2 * 60000 + 06 * 1000,3 * 60000 + 48 * 1000,1 * 60000 + 57 * 1000,
				2 * 60000 + 18 * 1000,2 * 60000 + 25 * 1000,2 * 60000 + 52 * 1000,2 * 60000 + 27 * 1000,2 * 60000 + 59 * 1000,2 * 60000 + 45 * 1000,2 * 60000 + 18 * 1000,1 * 60000 + 53 * 1000,2 * 60000 + 44 * 1000,2 * 60000 + 16 * 1000,
				2 * 60000 + 04 * 1000,2 * 60000 + 19 * 1000,2 * 60000 + 03 * 1000,2 * 60000 + 13 * 1000,2 * 60000 + 37 * 1000,2 * 60000 + 37 * 1000,2 * 60000 + 26 * 1000,2 * 60000 + 07 * 1000,2 * 60000 + 28 * 1000,2 * 60000 + 00 * 1000,
				2 * 60000 + 41 * 1000,2 * 60000 + 16 * 1000,2 * 60000 + 07 * 1000,2 * 60000 + 16 * 1000,3 * 60000 + 04 * 1000,3 * 60000 + 22 * 1000,3 * 60000 + 02 * 1000,3 * 60000 + 19 * 1000,2 * 60000 + 32 * 1000,3 * 60000 + 23 * 1000,
				2 * 60000 + 49 * 1000,2 * 60000 + 30 * 1000,2 * 60000 + 13 * 1000,2 * 60000 + 20 * 1000,1 * 60000 + 48 * 1000,2 * 60000 + 34 * 1000,2 * 60000 + 16 * 1000,1 * 60000 + 45 * 1000,2 * 60000 + 01 * 1000,2 * 60000 + 32 * 1000,
				2 * 60000 + 07 * 1000,3 * 60000 + 07 * 1000,2 * 60000 + 44 * 1000,2 * 60000 + 34 * 1000,2 * 60000 + 12 * 1000,2 * 60000 + 28 * 1000,2 * 60000 + 32 * 1000,2 * 60000 + 53 * 1000,2 * 60000 + 38 * 1000,2 * 60000 + 38 * 1000,
				4 * 60000 + 10 * 1000,3 * 60000 + 09 * 1000,4 * 60000 + 13 * 1000,2 * 60000 + 01 * 1000,2 * 60000 + 20 * 1000,2 * 60000 + 02 * 1000,2 * 60000 + 11 * 1000,2 * 60000 + 31 * 1000,2 * 60000 + 32 * 1000,2 * 60000 + 36 * 1000,
				5 * 60000 + 46 * 1000,3 * 60000 + 12 * 1000,2 * 60000 + 49 * 1000,2 * 60000 + 56 * 1000,3 * 60000 + 14 * 1000,2 * 60000 + 27 * 1000,2 * 60000 + 09 * 1000,2 * 60000 + 34 * 1000,2 * 60000 + 11 * 1000,2 * 60000 + 31 * 1000,
				2 * 60000 + 39 * 1000,2 * 60000 + 34 * 1000,3 * 60000 + 07 * 1000,3 * 60000 + 12 * 1000,4 * 60000 + 16 * 1000,4 * 60000 + 04 * 1000,2 * 60000 + 16 * 1000,2 * 60000 + 32 * 1000,3 * 60000 + 05 * 1000,3 * 60000 + 01 * 1000,
				2 * 60000 + 39 * 1000,2 * 60000 + 35 * 1000,2 * 60000 + 43 * 1000,2 * 60000 + 44 * 1000,2 * 60000 + 02 * 1000,2 * 60000 + 08 * 1000,2 * 60000 + 03 * 1000,2 * 60000 + 07 * 1000,2 * 60000 + 04 * 1000,2 * 60000 + 24 * 1000,
				2 * 60000 + 24 * 1000,1 * 60000 + 41 * 1000,2 * 60000 + 21 * 1000,2 * 60000 + 47 * 1000,2 * 60000 + 23 * 1000,2 * 60000 + 24 * 1000,2 * 60000 + 01 * 1000,2 * 60000 + 11 * 1000,2 * 60000 + 02 * 1000,2 * 60000 + 24 * 1000,
				3 * 60000 + 32 * 1000,3 * 60000 + 14 * 1000,2 * 60000 + 38 * 1000,2 * 60000 + 17 * 1000,3 * 60000 + 49 * 1000,2 * 60000 + 50 * 1000,2 * 60000 + 34 * 1000,2 * 60000 + 59 * 1000,1 * 60000 + 31 * 1000,1 * 60000 + 38 * 1000,
				2 * 60000 + 15 * 1000,2 * 60000 + 17 * 1000,0 * 60000 + 00 * 1000,2 * 60000 + 00 * 1000,1 * 60000 + 54 * 1000,2 * 60000 + 07 * 1000,1 * 60000 + 35 * 1000,2 * 60000 + 20 * 1000,2 * 60000 + 05 * 1000,1 * 60000 + 32 * 1000,
				1 * 60000 + 26 * 1000,4 * 60000 + 32 * 1000,3 * 60000 + 44 * 1000,3 * 60000 + 16 * 1000,3 * 60000 + 06 * 1000,3 * 60000 + 04 * 1000;

	// Test mode, Shortens Coutdown timer to 30 seconds for faster testing
	// [0] = Off
	// [1] = On
	.TestMode = 0;

// -------------------
//  Don't Touch Ever
// -------------------
	
	$@CurrentEvent = 0;
	if( .StartTime > 59 ) .StartTime = 59;
	if( .StartTime < 0 ) .StartTime = 0;
	setarray .Days$[0],"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday";
	end;
}


//==================================
//-- Emperium Event Extras
//==================================

sword_1-1,216,208,4	script	Emp_Break	-1,{
OnBreak:
	stopnpctimer;
	.@Time = getnpctimer(0);
	.@m = .@Time / 60000;
	.@s = (.@Time - .@m * 60000) / 1000;
	.@ms = .@Time % 1000;
	if(.@Time < BestTime || !BestTime)
		BestTime = .@Time;
	if(.@Time < $@BestTime){
		$@BestTime = .@Time;
		$@BestCid = getcharid(0);
		announce "[Emperium Event]: "+strcharinfo(0)+" now holds the top time of "+((.@m)?callfunc("F_InsertPlural",.@i,"minute")+" ":"")+""+((.@s)?.@s+""+((.@ms)?"."+.@ms:"")+" seconds":"")+".",bc_all|bc_blue;
	}
	mapannounce 'Map$,"You have a "+((.@Time == BestTime)?"new personal best ":"")+"time of "+((.@m)?callfunc("F_InsertPlural",.@i,"minute")+" ":"")+""+((.@s)?.@s+""+((.@ms)?"."+.@ms:"")+" seconds":"")+".",bc_area|bc_blue;
	sleep2 2500;
	instance_destroy;
	end;

OnInstanceInit:
	initnpctimer;
	stopnpctimer;
	setnpctimer 0,strnpcinfo(3);
	'Map$ = strnpcinfo(4);
	monster 'Map$,223,206,"Emperium",1288,1,strnpcinfo(3)+"::OnBreak";
	'GID = $@mobid;
	setunitdata 'GID,UMOB_DMGIMMUNE,1;
	sleep 2000;
	mapannounce 'Map$,"[Emperium Event]: Goal is simple, kill the Emperium as fast as you can~",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"[Emperium Event]: Once Countdown is done have at it.",bc_map|bc_blue;
	sleep 2000;
	mapannounce 'Map$,"5",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"4",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"3",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"2",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"1",bc_map|bc_blue;
	sleep 1000;
	mapannounce 'Map$,"Go~",bc_map|bc_blue;
	startnpctimer strnpcinfo(3);
	setunitdata 'GID,UMOB_DMGIMMUNE,0;
	end;
}

//==================================
//-- Maze Event Extras
//==================================

maze,358,148,0	warp	mazeroadblock	2,2,maze,371,149

maze,369,162,4	script	Event_Agent#Maze	405,4,4,{
	mes "[Event Agent]";
	mes "Walk up to me to claim prize~";
	close;

OnTouch_:
	if($@CurrentEvent == -5){
		$@CurrentEvent = 0;
		Func_Prizes(getcharid(0),"Maze Event");
		mapwarp "maze","prontera",155,172;
	}
	warp "prontera",155,172;
	end;
}

//==================================
//-- Cluckers Event 
//==================================

prontera,155,227,4	script	Cluckers	800,{
	if ($@CurrentEvent == -7) {
		specialeffect2 EF_HIT3;
		switch(rand(16)) {
			case 0: npctalk "CLUUUUUUCK!!!"; unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; emotion ET_HUK; break;
			case 1: npctalk "Cluuuuuck!~"; break;
			case 2: unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; break;
			case 3: sc_start SC_Freeze,10000,0; break;
			case 4: npctalk "CLUUUUUUUUUCK!!!"; unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; emotion ET_HUK; break;
			case 5: sc_start SC_Sleep,10000,0; break;
			case 6: sc_start SC_Stone,10000,0; emotion ET_KIK; break;
			case 7: npctalk "CLUUUUUUCK!!!"; unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; emotion ET_HUK; break;
			case 8: npctalk "Cluck! CLUUUCK!!"; unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; emotion ET_HUK; break;
			case 9: sc_start SC_Stun,10000,0; break;
			case 10: sc_start SC_Sleep,10000,0; emotion ET_KIK; break;
			case 11: npctalk "Cluck! Cluck!"; break;
			case 12: sc_start SC_Stun,10000,0; break;
			case 13: unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1; break;
			default:
				if (!rand(7)) {
					npctalk "WOOF!...........";
					specialeffect2 EF_SPHERE;
					Func_Prizes(getcharid(0),"Cluckers Event");
					$@CurrentEvent = 0;
				} else {
					npctalk "Cluck! CLUUUCK!!";
					unitkill getcharid(3); skilleffect "NPC_SELFDESTRUCTION",1;
					npcwalkto rand(152,159),rand(234,241);
				}
				break;
		}
		end;
	}
	mes "Cluck cluck! Cluuuuuck?";
	mes "Cluck....";
	close;

OnTimer15000:
	npcwalkto 70+rand(17),135+rand(16);
	setnpctimer 0;
	end;

OnInit:
	npcspeed 75;
	npcwalkto rand(152,159),rand(234,241);
 	initnpctimer;
	end;

OnEventStart:
	$@CurrentEvent = 7;
	for(.@i = 5; .@i > 0; .@i--){
		announce "Cluckers Event Will begin in "+callfunc("F_InsertPlural",.@i,"minute")+"!",bc_blue;
		announce "Please type @joinevent to join",bc_blue;
		sleep 60000;
	}
	announce "Cluckers Event Has Begun!",bc_blue;
	$@CurrentEvent = -7;
	sleep 60000 * 45;
	if($@CurrentEvent == -7){
		$@CurrentEvent = 0;
		announce "Cluckers Event Has Ended with No Winner!",bc_blue|bc_area|bc_npc;
	}
	end;
}

pvp_n_1-5,100,100,4	script	Disguise Event	795,{
	if($@CurrentEvent == -15){
		if(getgmlevel() == 99)
			dispbottom $MonsterName$+"";
		input .@input$;
		if(.@input$ == $MonsterName$)
			doevent strnpcinfo(3)+"::OnCorrect";
	}
	end;

OnStart:
	.EventON = .Wait = 1;
	setnpctimer 0;
	initnpctimer;
	end;

OnTimer10000:
	if (.Change) end;
	.Wait = 0;

OnDisguise:
	if (.MVPRule) {
		.Winner = 0;
		.Monster = rand(getarraysize(.MVP));
		$MonsterName$ = getmonsterinfo(.MVP[.Monster],0);
	} else {
		.Winner = 0;
		.Monster = 1000+rand(1000,1995);
		if (compare(","+.BlackList$+"," , ","+.Monster+",") || .Monster == .LastMonster)
			goto OnDisguise;
		.LastMonster = .Monster;
		$MonsterName$ = getmonsterinfo(.Monster,0);
	}
	deletepset 1;
	defpattern 1,"([^:]+):.\\s*"+$MonsterName$+".*", "OnCorrect";
	activatepset 1;
	if (.MVPRule)
		setnpcdisplay "Disguise Event",.MVP[.Monster];
	else	setnpcdisplay "Disguise Event",.Monster;
	.Change = 1;
	setnpctimer 0;
	end;

OnTimer30000:
	.Change = 0;
	setnpcdisplay "Disguise Event",795;
	npctalk "Disguise Event : You took too long to guess what I was. Please wait 10 seconds while I disguise again.";
	specialeffect EF_DETECT2;
	set $MonsterName$,"";
	deletepset 1;
	stopnpctimer;
	setnpctimer 0;
	initnpctimer;
	end;

OnCorrect:
	if (.Winner) {
		dispbottom "Someone has already won this round.";
		end;
	}
	set .Winner,1;
	set .RoundCount,.RoundCount+1;
	deletepset 1;
	activatepset 1;
	specialeffect2 EF_SPHERE;
	Func_Prizes(getcharid(0),"Disguise Event");
	if (.RoundCount >= .DisguiseRound) {
		setnpcdisplay "Disguise Event",795;
		.RoundCount = .Change = .EventON = 0;
		$@CurrentEvent = 0;
		setnpctimer 0;
		stopnpctimer;
		npctalk "Disguise Event : Thank you all for playing. That was the last round of the Disguise Event. Come play again later.";
		mapwarp "pvp_n_1-5","prontera",155,172;
		end;
	}
	setnpcdisplay "Disguise Event",795;
	.Change = 0;
	setnpctimer 0;
	end;

OnInit:
	// Npc Name
	.n$ = "[^0000FFDisguise NPC^000000]";

	// Disguise Event MVP Ruleset
	// Toggle 1/0
	// [0] Normal monsters, except blacklist
	// [1] MVPs from list
	.MVPRule = 1;

	// Number of rounds for Disguise Event
	.DisguiseRound = 5;
	$@DisguiseNpc$ = strnpcinfo(3);
	// MVP List
	setarray .MVP[0],1038,1039,1046,1059,1086,1087,1112,1115,1147,1150,1157,1159,1190,1251,1252,1272,1312,1373,
			1389,25156,1418,1492,1502,1511,1583,1623,1630,1646,1647,1648,1649,1650,1651,1658,1685,1688,
			1708,1719,1734,1751,1768,1779,1785,1802,1832,1871,1874,1885,1917,1980,2022,2068,2087,2131,
			2156,2165;

	// Blacklist
	set .BlackList$, "1003,1006,1017,1021,1022,1027,1043,1075,1136,1137,1168," + 
		"1171,1172,1173,1181,1187,1210,1217,1218,1222,1223,1224,1225,1226,1227,1228," + 
		"1233,1284,1407,1411,1414,1495,1501,1900,1996,2000,2001,2002,2003,2004," + 
		"2005,2006,2007,2011,2012,2025,2028,2029,2030,2031,2032,2033,2034,2035," + 
		"2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049," + 
		"2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063," + 
		"2064,2065,2066,2067,2075,2076,2077,2078,2079,2080,2081,2083,2084,2085," + 
		"2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099," + 
		"2100,2101,2012,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113," + 
		"2114,2115,2116,2117,2118,2119,2120,2121,2123,2124,2125,1496,";
		
	disablenpc $@DisguiseNpc$;
}

//==================================
//-- Event Shops
//==================================

prt_in,136,31,3	itemshop	Event Costume Shop	877,33001,20350:10,20351:10,20352:10,20353:10,20354:10,20355:10,20356:10,20357:10,20358:10,20359:10,20360:10,20361:10,20362:10,20363:10,20364:10,20365:10,20366:10,20367:10,20368:10,20369:10,20370:10,31063:10,31064:10,31065:10,31066:10,31067:10,31068:10,31069:10,31070:10,31071:10,31072:10,31073:10,31074:10,31075:10,31076:10,31077:10,31078:10,31079:10,31080:10,31081:10,31082:10,31083:10,31084:10,31085:10,31086:10,31329:30,31407:30,31062:50,31405:50,31149:50,31406:50,19291:100
